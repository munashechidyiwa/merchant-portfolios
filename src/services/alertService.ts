
import { dataProcessor } from '@/utils/dataProcessing';
import { communicationService } from './communicationService';

export interface SystemAlert {
  id: string;
  type: 'Terminal Inactive' | 'Follow-up Overdue' | 'Revenue Threshold' | 'Training Required' | 'Performance Issue';
  severity: 'High' | 'Medium' | 'Low';
  message: string;
  merchant: string;
  officer: string;
  timestamp: string;
  status: 'Unread' | 'Read' | 'Acknowledged' | 'Resolved';
  terminalId?: string;
  actionRequired: string;
  dueDate: string;
  autoGenerated: boolean;
}

export interface AlertSettings {
  id: string;
  name: string;
  description: string;
  enabled: boolean;
  threshold: string;
  emailNotification: boolean;
  priority: 'High' | 'Medium' | 'Low';
}

export class AlertService {
  private defaultSettings: AlertSettings[] = [
    {
      id: 'terminal-inactive',
      name: 'Terminal Inactivity',
      description: 'Alert when terminals are inactive for specified duration',
      enabled: true,
      threshold: '3 days',
      emailNotification: true,
      priority: 'High'
    },
    {
      id: 'follow-up-overdue',
      name: 'Overdue Follow-ups',
      description: 'Alert when follow-up actions are overdue',
      enabled: true,
      threshold: '1 day',
      emailNotification: true,
      priority: 'Medium'
    },
    {
      id: 'revenue-threshold',
      name: 'Revenue Milestones',
      description: 'Alert when merchants reach revenue thresholds',
      enabled: true,
      threshold: '10% below target',
      emailNotification: false,
      priority: 'Low'
    },
    {
      id: 'performance-decline',
      name: 'Performance Decline',
      description: 'Alert when terminal performance significantly drops',
      enabled: true,
      threshold: '50% decrease',
      emailNotification: true,
      priority: 'High'
    }
  ];

  generateSystemAlerts(): SystemAlert[] {
    const processedData = dataProcessor.getProcessedData();
    const alerts: SystemAlert[] = [];
    
    // Generate terminal inactivity alerts
    const inactiveAlerts = this.generateInactivityAlerts(processedData);
    alerts.push(...inactiveAlerts);
    
    // Generate performance alerts
    const performanceAlerts = this.generatePerformanceAlerts(processedData);
    alerts.push(...performanceAlerts);
    
    // Generate revenue threshold alerts
    const revenueAlerts = this.generateRevenueAlerts(processedData);
    alerts.push(...revenueAlerts);
    
    return alerts;
  }
  
  private generateInactivityAlerts(processedData: any): SystemAlert[] {
    const alerts: SystemAlert[] = [];
    
    processedData.terminalData.forEach((terminal: any) => {
      if (terminal.status === 'Inactive') {
        const lastTransaction = new Date(terminal.lastTransaction);
        const today = new Date();
        const daysDiff = Math.floor((today.getTime() - lastTransaction.getTime()) / (1000 * 60 * 60 * 24));
        
        if (daysDiff >= 3) {
          const severity = daysDiff >= 7 ? 'High' : daysDiff >= 5 ? 'Medium' : 'Low';
          
          alerts.push({
            id: `ALERT_${Date.now()}_${terminal.terminalId}`,
            type: 'Terminal Inactive',
            severity,
            message: `Terminal ${terminal.terminalId} at ${terminal.merchantName} has been inactive for ${daysDiff} days`,
            merchant: terminal.merchantName,
            officer: terminal.officer,
            timestamp: new Date().toISOString(),
            status: 'Unread',
            terminalId: terminal.terminalId,
            actionRequired: daysDiff >= 7 ? 'Site Visit Required' : 'Contact Merchant',
            dueDate: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),
            autoGenerated: true
          });
        }
      }
    });
    
    return alerts;
  }
  
  private generatePerformanceAlerts(processedData: any): SystemAlert[] {
    const alerts: SystemAlert[] = [];
    
    // Check for merchants with significant revenue decline
    processedData.merchantData.forEach((merchant: any) => {
      const currentMonth = merchant.monthToDateTotal;
      const expectedTarget = 20000; // Base target amount
      
      if (currentMonth < expectedTarget * 0.5) { // 50% below expected
        alerts.push({
          id: `PERF_${Date.now()}_${merchant.terminalId}`,
          type: 'Performance Issue',
          severity: 'High',
          message: `${merchant.merchantName} performance significantly below target (${((currentMonth / expectedTarget) * 100).toFixed(1)}% of target)`,
          merchant: merchant.merchantName,
          officer: merchant.supportOfficer,
          timestamp: new Date().toISOString(),
          status: 'Unread',
          terminalId: merchant.terminalId,
          actionRequired: 'Performance Review Meeting',
          dueDate: new Date(Date.now() + 3 * 24 * 60 * 60 * 1000).toISOString(),
          autoGenerated: true
        });
      }
    });
    
    return alerts;
  }
  
  private generateRevenueAlerts(processedData: any): SystemAlert[] {
    const alerts: SystemAlert[] = [];
    
    // Check for merchants exceeding targets
    processedData.merchantData.forEach((merchant: any) => {
      const currentMonth = merchant.monthToDateTotal;
      const expectedTarget = 20000; // Base target amount
      
      if (currentMonth > expectedTarget * 1.15) { // 15% above target
        alerts.push({
          id: `REV_${Date.now()}_${merchant.terminalId}`,
          type: 'Revenue Threshold',
          severity: 'Low',
          message: `${merchant.merchantName} has exceeded monthly target by ${((currentMonth / expectedTarget - 1) * 100).toFixed(1)}%`,
          merchant: merchant.merchantName,
          officer: merchant.supportOfficer,
          timestamp: new Date().toISOString(),
          status: 'Unread',
          terminalId: merchant.terminalId,
          actionRequired: 'Congratulate & Explore Growth Opportunities',
          dueDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(),
          autoGenerated: true
        });
      }
    });
    
    return alerts;
  }
  
  getAlertSettings(): AlertSettings[] {
    // In a real implementation, this would fetch from a database
    return this.defaultSettings;
  }
  
  updateAlertSettings(settings: AlertSettings[]): void {
    // In a real implementation, this would save to a database
    console.log('Alert settings updated:', settings);
  }
  
  acknowledgeAlert(alertId: string): void {
    console.log(`Alert ${alertId} acknowledged`);
  }
  
  resolveAlert(alertId: string): void {
    console.log(`Alert ${alertId} resolved`);
  }
}

export const alertService = new AlertService();
