import { databaseService } from "./databaseService";
import { dataProcessor } from "@/utils/dataProcessing";

export interface AutoGeneratedCommunication {
  id: string;
  merchantName: string;
  merchantId: string;
  terminalId: string;
  type: string;
  date: string;
  officer: string;
  officerEmail: string;
  subject: string;
  notes: string;
  status: string;
  followUpDate: string;
  inactiveDays: number;
  autoGenerated: boolean;
}

export const communicationService = {
  async generateAutoCommunications(): Promise<AutoGeneratedCommunication[]> {
    try {
      const processedData = await dataProcessor.getProcessedData();
      const communications: AutoGeneratedCommunication[] = [];

      // Generate communications for inactive merchants
      const inactiveMerchants = processedData.merchantData.filter(merchant => 
        merchant.status === 'Inactive' || 
        new Date(merchant.last_activity) < new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)
      );

      for (const merchant of inactiveMerchants) {
        const daysSinceLastActivity = Math.floor(
          (Date.now() - new Date(merchant.last_activity).getTime()) / (24 * 60 * 60 * 1000)
        );

        communications.push({
          id: `comm_${merchant.id}_${Date.now()}`,
          merchantName: merchant.merchant_name,
          merchantId: merchant.id,
          terminalId: merchant.terminal_id,
          type: 'Follow-up',
          date: new Date().toISOString().split('T')[0],
          officer: merchant.support_officer,
          officerEmail: `${merchant.support_officer.toLowerCase().replace(' ', '.')}@bank.com`,
          subject: `Follow-up Required: ${merchant.merchant_name} - ${daysSinceLastActivity} days inactive`,
          notes: `Merchant has been inactive for ${daysSinceLastActivity} days. Last activity: ${new Date(merchant.last_activity).toLocaleDateString()}`,
          status: 'Pending',
          followUpDate: new Date(Date.now() + 3 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
          inactiveDays: daysSinceLastActivity,
          autoGenerated: true
        });
      }

      // Generate communications for low-performing merchants
      const lowPerformingMerchants = processedData.merchantData.filter(merchant => 
        merchant.contribution_percentage < 2.0 && merchant.status === 'Active'
      );

      for (const merchant of lowPerformingMerchants) {
        communications.push({
          id: `comm_${merchant.id}_performance_${Date.now()}`,
          merchantName: merchant.merchant_name,
          merchantId: merchant.id,
          terminalId: merchant.terminal_id,
          type: 'Performance Review',
          date: new Date().toISOString().split('T')[0],
          officer: merchant.support_officer,
          officerEmail: `${merchant.support_officer.toLowerCase().replace(' ', '.')}@bank.com`,
          subject: `Performance Review: ${merchant.merchant_name} - Low contribution (${merchant.contribution_percentage}%)`,
          notes: `Merchant contribution is below threshold at ${merchant.contribution_percentage}%. Consider support strategies.`,
          status: 'Pending',
          followUpDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
          inactiveDays: 0,
          autoGenerated: true
        });
      }

      return communications;
    } catch (error) {
      console.error('Error generating auto communications:', error);
      return [];
    }
  },

  async getCommunications(): Promise<AutoGeneratedCommunication[]> {
    try {
      // Fetch communications from the database
      const { data, error } = await supabase.from('communications').select('*');

      if (error) {
        console.error('Error fetching communications:', error);
        return [];
      }

      return data as AutoGeneratedCommunication[];
    } catch (error) {
      console.error('Error getting communications:', error);
      return [];
    }
  },

  async createCommunication(communicationData: any): Promise<any> {
    try {
      // Create a new communication in the database
      const { data, error } = await supabase
        .from('communications')
        .insert([communicationData])
        .select();

      if (error) {
        console.error('Error creating communication:', error);
        throw error;
      }

      return data;
    } catch (error) {
      console.error('Error creating communication:', error);
      throw error;
    }
  },

  async updateCommunication(id: string, updates: Partial<AutoGeneratedCommunication>): Promise<any> {
    try {
      // Update a communication in the database
      const { data, error } = await supabase
        .from('communications')
        .update(updates)
        .eq('id', id)
        .select();

      if (error) {
        console.error('Error updating communication:', error);
        throw error;
      }

      return data;
    } catch (error) {
      console.error('Error updating communication:', error);
      throw error;
    }
  },

  async deleteCommunication(id: string): Promise<boolean> {
    try {
      // Delete a communication from the database
      const { error } = await supabase
        .from('communications')
        .delete()
        .eq('id', id);

      if (error) {
        console.error('Error deleting communication:', error);
        return false;
      }

      return true;
    } catch (error) {
      console.error('Error deleting communication:', error);
      return false;
    }
  }
};

import { createClient } from '@supabase/supabase-js';

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || '';
const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || '';
const supabase = createClient(supabaseUrl, supabaseKey);
